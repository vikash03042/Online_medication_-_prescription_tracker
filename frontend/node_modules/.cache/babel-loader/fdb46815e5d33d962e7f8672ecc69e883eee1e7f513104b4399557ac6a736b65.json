{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { getSliced } from './getSliced';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n\n/**\n * A subset of d3-scale that Recharts is using\n */\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n  if (!scale) {\n    return null;\n  }\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset,\n        index\n      };\n    });\n    return result.filter(row => !isNan(row.coordinate));\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset,\n      index\n    }));\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = scale => {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var minValue = Math.min(range[0], range[1]) - EPS;\n  var maxValue = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = series => {\n  var _series$;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var series1 = col[1];\n      var series0 = col[0];\n      var value = isNan(series1) ? series0 : series1;\n      if (value >= 0) {\n        col[0] = positive;\n        col[1] = positive + value;\n        positive = series1;\n      } else {\n        col[0] = negative;\n        col[1] = negative + value;\n        negative = series1;\n      }\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = series => {\n  var _series$2;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$2 = series[0]) === null || _series$2 === void 0 ? void 0 : _series$2.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var value = isNan(col[1]) ? col[0] : col[1];\n      if (value >= 0) {\n        col[0] = positive;\n        col[1] = positive + value;\n        // eslint-disable-next-line prefer-destructuring\n        positive = col[1];\n      } else {\n        col[0] = 0;\n        col[1] = 0;\n      }\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var _STACK_OFFSET_MAP$off;\n  var offsetAccessor = (_STACK_OFFSET_MAP$off = STACK_OFFSET_MAP[offsetType]) !== null && _STACK_OFFSET_MAP$off !== void 0 ? _STACK_OFFSET_MAP$off : stackOffsetNone;\n  var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  var result = stack(data);\n\n  // Post-process ranged data: if value is an array of two numbers, use them directly without stacking\n  result.forEach((series, seriesIndex) => {\n    series.forEach((point, pointIndex) => {\n      var value = getValueByDataKey(data[pointIndex], dataKeys[seriesIndex], 0);\n      if (Array.isArray(value) && value.length === 2 && isNumber(value[0]) && isNumber(value[1])) {\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[0] = value[0];\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[1] = value[1];\n      }\n    });\n  });\n  return result;\n};\n\n/**\n * Externally, we accept both strings and numbers as stack IDs\n * @inline\n */\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  return !isNullish(value) ? axis.scale(value) : null;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]);\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    if (!group) {\n      return result;\n    }\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var sliced = getSliced(entry, startIndex, endIndex);\n      var s = getDomainOfSingle(sliced);\n      if (!isWellBehavedNumber(s[0]) || !isWellBehavedNumber(s[1])) {\n        return res;\n      }\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min(((cur === null || cur === void 0 ? void 0 : cur.coordinate) || 0) - ((prev === null || prev === void 0 ? void 0 : prev.coordinate) || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n  return undefined;\n}\nexport var calculateCartesianTooltipPos = (coordinate, layout) => {\n  if (layout === 'horizontal') {\n    return coordinate.chartX;\n  }\n  if (layout === 'vertical') {\n    return coordinate.chartY;\n  }\n  return undefined;\n};\nexport var calculatePolarTooltipPos = (rangeObj, layout) => {\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n  return rangeObj.radius;\n};","map":{"version":3,"names":["ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","sortBy","get","stack","shapeStack","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderNone","findEntryInArray","isNan","isNullish","isNumber","isNumOrStr","mathSign","getSliced","isWellBehavedNumber","getValueByDataKey","obj","dataKey","defaultValue","appendOffsetOfLegend","offset","legendSettings","legendSize","width","boxWidth","height","boxHeight","align","verticalAlign","layout","isCategoricalAxis","axisType","getCoordinatesOfGrid","ticks","minValue","maxValue","syncWithTicks","map","entry","coordinate","hasMin","hasMax","values","getTicksOfAxis","axis","isGrid","isAll","duplicateDomain","type","range","scale","realScaleType","isCategorical","categoricalDomain","tickCount","niceTicks","offsetForBand","bandwidth","result","index","scaleContent","indexOf","row","domain","EPS","checkDomainOfScale","len","Math","min","max","first","last","truncateByDomain","offsetSign","series","_series$","n","m","j","positive","negative","col","series1","series0","offsetPositive","_series$2","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","data","dataKeys","offsetType","_STACK_OFFSET_MAP$off","offsetAccessor","d","key","order","seriesIndex","point","pointIndex","Array","isArray","getNormalizedStackId","publicStackId","undefined","getCateCoordinateOfLine","_ref","bandSize","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref2","getBaseValueOfBar","_ref3","numericAxis","getDomainOfSingle","flat","makeDomainFinite","Infinity","getDomainOfStackGroups","stackGroups","startIndex","endIndex","reduce","stackId","group","stackedData","res","sliced","s","MIN_VALUE_REG","MAX_VALUE_REG","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","cur","prev","getTooltipEntry","_ref4","tooltipEntrySettings","payload","name","getTooltipNameProp","nameFromItem","calculateCartesianTooltipPos","chartX","chartY","calculatePolarTooltipPos","rangeObj","angle","radius"],"sources":["C:/Users/HP/Desktop/Online_medication_-_prescription_tracker/frontend/node_modules/recharts/es6/util/ChartUtils.js"],"sourcesContent":["function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { getSliced } from './getSliced';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n\n/**\n * A subset of d3-scale that Recharts is using\n */\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n  if (!scale) {\n    return null;\n  }\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset,\n        index\n      };\n    });\n    return result.filter(row => !isNan(row.coordinate));\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset,\n      index\n    }));\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = scale => {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var minValue = Math.min(range[0], range[1]) - EPS;\n  var maxValue = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = series => {\n  var _series$;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var series1 = col[1];\n      var series0 = col[0];\n      var value = isNan(series1) ? series0 : series1;\n      if (value >= 0) {\n        col[0] = positive;\n        col[1] = positive + value;\n        positive = series1;\n      } else {\n        col[0] = negative;\n        col[1] = negative + value;\n        negative = series1;\n      }\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = series => {\n  var _series$2;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$2 = series[0]) === null || _series$2 === void 0 ? void 0 : _series$2.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var value = isNan(col[1]) ? col[0] : col[1];\n      if (value >= 0) {\n        col[0] = positive;\n        col[1] = positive + value;\n        // eslint-disable-next-line prefer-destructuring\n        positive = col[1];\n      } else {\n        col[0] = 0;\n        col[1] = 0;\n      }\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var _STACK_OFFSET_MAP$off;\n  var offsetAccessor = (_STACK_OFFSET_MAP$off = STACK_OFFSET_MAP[offsetType]) !== null && _STACK_OFFSET_MAP$off !== void 0 ? _STACK_OFFSET_MAP$off : stackOffsetNone;\n  var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  var result = stack(data);\n\n  // Post-process ranged data: if value is an array of two numbers, use them directly without stacking\n  result.forEach((series, seriesIndex) => {\n    series.forEach((point, pointIndex) => {\n      var value = getValueByDataKey(data[pointIndex], dataKeys[seriesIndex], 0);\n      if (Array.isArray(value) && value.length === 2 && isNumber(value[0]) && isNumber(value[1])) {\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[0] = value[0];\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[1] = value[1];\n      }\n    });\n  });\n  return result;\n};\n\n/**\n * Externally, we accept both strings and numbers as stack IDs\n * @inline\n */\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  return !isNullish(value) ? axis.scale(value) : null;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]);\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    if (!group) {\n      return result;\n    }\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var sliced = getSliced(entry, startIndex, endIndex);\n      var s = getDomainOfSingle(sliced);\n      if (!isWellBehavedNumber(s[0]) || !isWellBehavedNumber(s[1])) {\n        return res;\n      }\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min(((cur === null || cur === void 0 ? void 0 : cur.coordinate) || 0) - ((prev === null || prev === void 0 ? void 0 : prev.coordinate) || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n  return undefined;\n}\nexport var calculateCartesianTooltipPos = (coordinate, layout) => {\n  if (layout === 'horizontal') {\n    return coordinate.chartX;\n  }\n  if (layout === 'vertical') {\n    return coordinate.chartY;\n  }\n  return undefined;\n};\nexport var calculatePolarTooltipPos = (rangeObj, layout) => {\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n  return rangeObj.radius;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}